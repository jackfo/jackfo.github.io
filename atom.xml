<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>敏而好学,乐以忘忧</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cfad.tech/"/>
  <updated>2017-12-12T15:45:14.000Z</updated>
  <id>http://www.cfad.tech/</id>
  
  <author>
    <name>cfs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A example of Netty</title>
    <link href="http://www.cfad.tech/2017/12/12/netty/netty1/"/>
    <id>http://www.cfad.tech/2017/12/12/netty/netty1/</id>
    <published>2017-12-12T12:34:14.000Z</published>
    <updated>2017-12-12T15:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="the-introduce-of-netty">The introduce of Netty</span></h1><p>        we often use an HTTP client library to retrieve information from a web server and to invoke a remote procedure call via web services. Netty is an NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server development.</p><h1><span id="a-example-of-netty">A example of Netty</span></h1><h2><span id="the-main-class">The Main class</span></h2><p>        In this part, we introduce a simple process for a netty service. At first, we create multithreaded event loop that handles I/O operation and add them into corresponding server and add corresponding channel to transmit message. In this channel, we will create corresponding handle to receive the message, In this process, some handle can encode or decode the message. In the end, it will wait the message from client.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//bossGroup will accept an incoming connection</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//workerGroup handles the traffic of the accepted connection once the bossGroup accepts the connection</span></span><br><span class="line">        <span class="comment">//and registers the accepted the connection to the worker</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//ServerBootstrap is a helper class that sets up a server. you can set up the server using channel</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//we specify to use the NioServerSocketChannel class which is used to a new channel to accept incoming connection</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//the handler specified here will always be evaluated by a newly channel</span></span><br><span class="line">                    <span class="comment">//The ChannelInitializer's purpose is to help user configure a new channel and add some handler which can implement network application</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//you can set some socket option by this way</span></span><br><span class="line">                    <span class="comment">//option() is for the NioServerSocketChannel that accepts incoming connections.</span></span><br><span class="line">                    <span class="comment">//childOption() is for the Channels accepted by the parent ServerChannel, which is NioServerSocketChannel in this case.</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></span><br><span class="line">            ChannelFuture f = serverBootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"before closeFuture.."</span>);</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></span><br><span class="line">            <span class="comment">// shut down your server.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">            System.out.println(<span class="string">"after closeFuture.."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">8080</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> DiscardServer(port).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">## The corresponding handle</span><br><span class="line"> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; In <span class="keyword">this</span> handle,  we override the channelRead method from the <span class="class"><span class="keyword">interface</span> <span class="title">of</span> <span class="title">ChannelInboundHandler</span> <span class="title">to</span> <span class="title">receive</span> <span class="title">the</span> <span class="title">message</span> <span class="title">and</span> <span class="title">do</span> <span class="title">some</span> <span class="title">operation</span>.</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">```<span class="title">java</span></span></span><br><span class="line"><span class="class">/***</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">ChannelInboundHandlerAdapter</span> <span class="title">is</span> <span class="title">a</span> <span class="title">implementation</span> <span class="title">for</span> <span class="title">ChannelHandlerAdapter</span> (<span class="title">abstract</span> <span class="title">class</span>) <span class="title">and</span> <span class="title">ChannelInboundHandler</span>(<span class="title">interface</span>)</span></span><br><span class="line"><span class="class"> * <span class="title">ChannelInboundHandler</span> <span class="title">provides</span> <span class="title">various</span> <span class="title">event</span> <span class="title">handler</span> <span class="title">methods</span> <span class="title">that</span> <span class="title">you</span> <span class="title">can</span> <span class="title">override</span></span></span><br><span class="line"><span class="class"> * <span class="title">For</span> <span class="title">now</span>, <span class="title">it</span> <span class="title">is</span> <span class="title">just</span> <span class="title">enough</span> <span class="title">to</span> <span class="title">extend</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="title">rather</span> <span class="title">than</span> <span class="title">to</span> <span class="title">implement</span> <span class="title">the</span> <span class="title">handler</span> <span class="title">interface</span> <span class="title">by</span> <span class="title">yourself</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * we override the channelRead method from the interface of ChannelInboundHandler</span></span><br><span class="line"><span class="comment">     * Invoked when the current channel has read a message from the peer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx this variable provide various operations that enable you to trigger various I/O operations and event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg receive the message from channel</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">char</span> temp ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ctx.write(<span class="string">"you message:"</span>);</span><br><span class="line">            <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line">                temp = (<span class="keyword">char</span>)in.readByte();</span><br><span class="line">                System.out.print(temp);</span><br><span class="line"></span><br><span class="line">                ctx.write(temp);</span><br><span class="line">                System.out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.flush();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exceptionCaught() event handler method s called with a Throwable</span></span><br><span class="line"><span class="comment">     * when an exception was raised by Netty due to an I/O error or by a handler implementation due to the exception thrown while processing events</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        System.out.println(<span class="string">"channelRead..."</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##The result of this example<img src="/media/15130934221050.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;the-introduce-of-netty&quot;&gt;The introduce of Netty&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;        we often use an HTTP client library to retrieve informat
      
    
    </summary>
    
      <category term="Netty" scheme="http://www.cfad.tech/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://www.cfad.tech/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>java NIO Selector</title>
    <link href="http://www.cfad.tech/2017/12/11/NIO/nio4/"/>
    <id>http://www.cfad.tech/2017/12/11/NIO/nio4/</id>
    <published>2017-12-11T12:34:14.000Z</published>
    <updated>2017-12-11T15:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>#The Selector, SelectableChannel, and SelectionKey Classes</p><h2><span id="selector">Selector</span></h2><p>        The Selector class manages information about a set of registered channel and their readies state. Channels are registered with selectors, and a selector can be asked to update readies state of channels. When doing so, the invoking thread can optionally indicate that it would prefer to be suspended until one of the registered channel is ready.</p><h2><span id=""></span></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#The Selector, SelectableChannel, and SelectionKey Classes&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;selector&quot;&gt;Selector&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;        The Selector class
      
    
    </summary>
    
      <category term="NIO" scheme="http://www.cfad.tech/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://www.cfad.tech/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>java NIO channel</title>
    <link href="http://www.cfad.tech/2017/12/11/NIO/nio3/"/>
    <id>http://www.cfad.tech/2017/12/11/NIO/nio3/</id>
    <published>2017-12-11T01:34:14.000Z</published>
    <updated>2017-12-11T15:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="java-nio-channel">java NIO channel</span></h1><p>   When it comes to NIO, the first New concept we approach is channel, we operate data by using it instead of stream in traditional IO.</p><h1><span id="the-introduce-of-channel">The introduce of channel</span></h1><h2><span id="what-is-channel">What is channel?</span></h2><p>        Channels is the second invocation of java NIO, they used to transmit data to the corresponding entity in both sides of the channel. Channels are gateways through which the native I/O services of the operating system can be accessed with a minimum of overhead, and buffers are the internal endpoints used by channels to send and receive data.</p><h2><span id="the-feature-of-channel">The feature of channel</span></h2><blockquote><p>1.channel both can read data also can write data2.channel can read or write data from asynchronous3.channel must have a buffer to transmit data</p></blockquote><h2><span id="the-family-of-channel">The family of channel</span></h2><p>java.nio.channels.Channel 接口：</p><blockquote><pre><code>|--FileChannel|--SocketChannel|--ServerSocketChannel|--DatagramChannel</code></pre></blockquote><p><img src="/media/15129757112556.jpg" alt=""></p><h1><span id="the-use-of-channel">The use of channel</span></h1><p>        In the above, we know about what is channel roughly. Now, we tell channel by using it.</p><h2><span id="copy-file-by-channel">Copy file by channel</span></h2><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//Getting channel</span></span><br><span class="line">FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line"></span><br><span class="line">inChannel = fis.getChannel();</span><br><span class="line">outChannel = fos.getChannel();</span><br><span class="line"><span class="comment">//allocate specified size buffer</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Getting data from channel, and storage it in buffer </span></span><br><span class="line"><span class="keyword">while</span>(inChannel.read(buf) != -<span class="number">1</span>)&#123;</span><br><span class="line">buf.flip(); <span class="comment">//Flips this buffer</span></span><br><span class="line"><span class="comment">//write the data in the buffer into the channel</span></span><br><span class="line">outChannel.write(buf);</span><br><span class="line"><span class="comment">//clear buffer, The position is set to zero, the limit is set to the capacity</span></span><br><span class="line">buf.clear(); </span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//handle corresponding exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; above the code, we get corresponding stream from File stream, then we write data to FileOutputStream. Now, we detail some of these method. `FileChannelImpl.open` will create corresponding instance.</span><br><span class="line"></span><br><span class="line"># A set of method of channel</span><br><span class="line">## getChannel()</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; `getChannel`method will Returns the unique FileChannel object associated with <span class="keyword">this</span> file input stream.</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The initial &#123;<span class="doctag">@link</span> java.nio.channels.FileChannel#position()</span></span><br><span class="line"><span class="comment">     * position&#125; of the returned channel will be equal to the</span></span><br><span class="line"><span class="comment">     * number of bytes read from the file so far.  Reading bytes from this</span></span><br><span class="line"><span class="comment">     * stream will increment the channel's position.  Changing the channel's</span></span><br><span class="line"><span class="comment">     * position, either explicitly or by reading, will change this stream's</span></span><br><span class="line"><span class="comment">     * file position.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the file channel associated with this file input stream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2><span id="read-bytebuffer-dst">read(ByteBuffer dst)</span></h2><p>        <code>read</code> is abstract method, it will read a sequence of bytes from this channel into the given buffer. Bytes are read starting at this channel's current file position, and then file position is updated with the number of bytes actually read.</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int read(ByteBuffer dst) throws IOException &#123;</span><br><span class="line">       ensureOpen();</span><br><span class="line">       if (!readable)</span><br><span class="line">           throw new NonReadableChannelException();</span><br><span class="line">       synchronized (positionLock) &#123;</span><br><span class="line">           int n = 0;</span><br><span class="line">           int ti = -1;</span><br><span class="line">           try &#123;</span><br><span class="line">               begin();</span><br><span class="line">               ti = threads.add();</span><br><span class="line">               if (!isOpen())</span><br><span class="line">                   return 0;</span><br><span class="line">               do &#123;</span><br><span class="line">                   n = IOUtil.read(fd, dst, -1, nd);</span><br><span class="line">              &#125; while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">               return IOStatus.normalize(n);</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               threads.remove(ti);</span><br><span class="line">               end(n &gt; 0);</span><br><span class="line">               assert IOStatus.check(n);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2><span id="write-bytebuffer-src">write(ByteBuffer src)</span></h2><p>        Writes a sequence of bytes to this channel from given buffer.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      ensureOpen();</span><br><span class="line">      <span class="keyword">if</span> (!writable)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NonWritableChannelException();</span><br><span class="line">      <span class="keyword">synchronized</span> (positionLock) &#123;</span><br><span class="line">          <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> ti = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              begin();</span><br><span class="line">              ti = threads.add();</span><br><span class="line">              <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  n = IOUtil.write(fd, src, -<span class="number">1</span>, nd);</span><br><span class="line">              &#125; <span class="keyword">while</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">              <span class="keyword">return</span> IOStatus.normalize(n);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              threads.remove(ti);</span><br><span class="line">              end(n &gt; <span class="number">0</span>);</span><br><span class="line">              <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;java-nio-channel&quot;&gt;java NIO channel&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;   When it comes to NIO, the first New concept we approach is channel, we op
      
    
    </summary>
    
      <category term="NIO" scheme="http://www.cfad.tech/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://www.cfad.tech/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>java NIO buffer</title>
    <link href="http://www.cfad.tech/2017/12/10/NIO/nio2/"/>
    <id>http://www.cfad.tech/2017/12/10/NIO/nio2/</id>
    <published>2017-12-10T11:00:00.000Z</published>
    <updated>2017-12-11T04:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="java-nio-buffer">java NIO buffer</span></h1><p>   A buffer Object is a container of a fixed amount of data, it acts as a block or staging area, where data can be stored and later retrieved.<strong>Buffers work hand in glove with channels</strong>, Channels are portals through which i/o transfers take place, and buffers are the sources or targets of those data transfers.</p><h2><span id="the-family-of-buffer-in-java-nio">The family of buffer in java nio</span></h2><p><img src="/media/15129174785464.jpg" alt=""></p><p>   From the system diagram, we can find each of the basic data types has their own corresponding buffer class. as follows:</p><hr><blockquote><p>ByteBuffershortBufferCharBufferIntBufferLongBufferFloatBufferDoubleBufferMappedByteBuffer</p></blockquote><h2><span id="attributes">Attributes</span></h2><p>   Buffer is mainly has four attributes</p><p><strong>Capacity:</strong>  The maximum number of data elements the buffer can hold. The capacity is set when the buffer is created and can never be changed.</p><p><strong>Limit:</strong>  The first element of the buffer that should not be read or written. In other words, the count of live elements in the buffer.</p><p>**Position:**The index of next element to be read or written. The position is updated automatically by <code>get()</code> and <code>put()</code> methods.</p><p><strong>Mark:</strong> A remembered position,<code>Mark()</code> and reset() are used together. when we use <code>Mark()</code>, we will record the position so that calling <code>reset()</code> sets <code>position = mark</code></p><p>The following relationship between these four attributes always holds:&lt;p style=&quot;text-align: center&quot;&gt;0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity&lt;/p&gt;</p><p><img src="/media/15129175076144.jpg" alt=""></p><h2><span id="buffer-interface">Buffer interface</span></h2><p><img src="/media/15129175281981.jpg" alt=""></p><h2><span id="the-usage-of-buffer">The Usage of Buffer</span></h2><p>   Now, i show how to use it and explain the source code through it's the implementation class --- ByteBuffer</p><h3><span id="the-constructor-of-it">The constructor of it</span></h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer(int mark, int pos, int lim, int cap, byte[] hb, int offset)</span><br><span class="line"> &#123;</span><br><span class="line">     super(mark, pos, lim, cap);</span><br><span class="line">     this.hb = hb;</span><br><span class="line">     this.offset = offset;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">     // Creates a new buffer with the given mark, position, limit, and capacity</span><br><span class="line"> ByteBuffer(int mark, int pos, int lim, int cap) &#123;         this(mark, pos, lim, cap, null, 0);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>     we can find the core of it invoke the superclass, at first we see the parent class constructor. it easy to find the superclass is <code>Buffer</code></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;      </span><br><span class="line">        <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative capacity: "</span> + cap);</span><br><span class="line">        <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">        limit(lim);</span><br><span class="line">        position(pos);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mark &gt; position: ("</span></span><br><span class="line">                                                   + mark + <span class="string">" &gt; "</span> + pos + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">this</span>.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this buffer's limit.  If the position is larger than the new limit</span></span><br><span class="line"><span class="comment">     * then it is set to the new limit.  If the mark is defined and larger than</span></span><br><span class="line"><span class="comment">     * the new limit then it is discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  newLimit</span></span><br><span class="line"><span class="comment">     *         The new limit value; must be non-negative</span></span><br><span class="line"><span class="comment">     *         and no larger than this buffer's capacity</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        limit = newLimit;</span><br><span class="line">        <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this buffer's position.  If the mark is defined and larger than the</span></span><br><span class="line"><span class="comment">     * new position then it is discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  newPosition</span></span><br><span class="line"><span class="comment">     *         The new position value; must be non-negative</span></span><br><span class="line"><span class="comment">     *         and no larger than the current limit</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  This buffer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        position = newPosition;</span><br><span class="line">        <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>         In this constructor, Main purpose is to give the corresponding handle to set the appropriate attribute values through the way of refs, these attributes was introduced in the above. Each method of them has corresponding judgment whether the property value whether meet the conditions. if not, it will throws corresponding exception.</p><h3><span id="allocate-a-specify-memory-space">allocate a specify memory space</span></h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//allocate a specify memory space</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">System.out.println(buf.position());</span><br><span class="line">System.out.println(buf.limit());</span><br><span class="line">System.out.println(buf.capacity());</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result:</span><br><span class="line">0</span><br><span class="line">1024</span><br><span class="line">1024</span><br></pre></td></tr></table></figure></p><p>        In the beginning of allocate a memory space to buffer, we can find the property value of <code>position</code> is 0, property values of <code>limit</code> and <code>capacity</code> is the value of the incoming.</p><h3><span id="buffer-after-five-put-s">Buffer after five put( )s</span></h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">      <span class="comment">//put data in the buffer</span></span><br><span class="line">buf.put(str.getBytes());</span><br><span class="line">System.out.println(buf.position());</span><br><span class="line">System.out.println(buf.limit());</span><br><span class="line">System.out.println(buf.capacity());</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result:</span><br><span class="line">5</span><br><span class="line">1024</span><br><span class="line">1024</span><br></pre></td></tr></table></figure></p><p>        Follow the above code, I convert a string into a byte array and store it the <code>buf</code> instance. From the result, we can find the <code>position</code> has some change, limit and capacity don't have any change. The model is shown.<img src="/media/15129175579354.jpg" alt=""></p><h3><span id="switch-to-read-data-mode">Switch to Read data mode</span></h3><p>       Continuing to follow the above code, we begin to read the data which we put in the above. At first we switch to read data mode by calling the <code>flip()</code> method.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf.flip();</span><br><span class="line">System.out.println(buf.position());</span><br><span class="line">System.out.println(buf.limit());</span><br><span class="line">System.out.println(buf.capacity());</span><br></pre></td></tr></table></figure></p><p>result:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br><span class="line">1024</span><br></pre></td></tr></table></figure></p><p>         Flips this buffer. The <code>limit</code> is set to the current <code>position</code> and then the <code>position</code> is set to zero. If the mark is defined then it is discarded.        After invoking the <code>flip()</code>, we begin to read the data in the buffer.</p><h3><span id="read-data-from-buffer">Read data from buffer</span></h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">buf.get(dst);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">System.out.println(buf.position());</span><br><span class="line">System.out.println(buf.limit());</span><br><span class="line">System.out.println(buf.capacity());</span><br></pre></td></tr></table></figure></p><p>result:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">1024</span><br></pre></td></tr></table></figure></p><p>         From the code, we can find we build a byte array to read data from buffer. after reading it, The property value of position changed. The principle of it is after we invoke the <code>get()</code> method It can read the Reads the byte at this buffer's current position, and then increments the position. The process of <code>get()</code> method is in its implementation class.</p><h3><span id="rewinds-this-buffer">Rewinds this buffer</span></h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      position = <span class="number">0</span>;</span><br><span class="line">      mark = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>        The position is set to zero and the mark is discarded. Invoking this method before a sequence of channel-write or get operations, assuming that the limit has already been set appropriately.</p><h3><span id="clears-this-buffer">Clears this buffer</span></h3><p>        The position is set to zero, the limit is set to the capacity, and the mark is discarded.This method does not actually erase the data in the buffer, but it is named as if it did because it will most often be used in situations in which that might as well be the case.</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="hasremaining">hasRemaining()</span></h3><p>        Tells whether there are any elements between the current position and the limit. if true, there is at least one element remaining in this buffer</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasRemaining() &#123;</span><br><span class="line">      return position &lt; limit;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2><span id="the-compare-buffers">The Compare Buffers</span></h2><h3><span id="direct-byte-buffers">Direct byte buffers</span></h3><p>        Direct byte buffers are usually the best choice for I/O operations. By design, they support the most efficient I/O mechanism available to the JVM.Direct buffers are optimal for I/O, but they may be more expensive to create than non direct byte buffers. The memory used by direct buffers is allocated by calling through to native, operating system-specific code, by passing the standard JVM heap. Setting up and tearing down direct buffers could be significantly more expensive than heap-resident buffers, depending on the host operating system and JVM implementation. The memory-storage areas of direct buffers are not subject to garbage collection because they are outside the standard JVM heap.      &lt;p style=&quot;text-align: right;&quot;&gt;---reference O’reilly java NIO &lt;/p&gt;<img src="/media/15129175838229.jpg" alt=""></p><h4><span id="the-method-of-creation">The Method of creation</span></h4><p><code>static ByteBuffer allocateDirect(int capacity)</code></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new direct byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero.  Whether or not it has a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #hasArray backing array&#125; is unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line"></span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">    att = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="non-direct-byte-buffers">Non direct byte buffers</span></h3><p>        Non direct byte buffers can be passed to channels, but doing so may incur a performance penalty. It's usually not possible for a non direct buffer to be the target of a native I/O operation. If you pass a non direct ByteBuffer object to a channel for write, the channel may implicitly do the following on each call:&gt; 1. Create a temporary direct ByteBuffer object.2. Copy the content of the non direct buffer to the temporary buffer.3. Perform the low-level I/O operation using the temporary buffer.4. The temporary buffer object goes out of scope and is eventually garbage collected.</p><p>&lt;p style=&quot;text-align: right;&quot;&gt;---reference O‘reilly java NIO &lt;/p&gt;</p><p><img src="/media/15129176007588.jpg" alt=""></p><h4><span id="the-method-of-creation">The Method of creation</span></h4><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Allocates a new byte buffer.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt; The new buffer's position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment">  * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment">  * initialized to zero.  It will have a &#123;<span class="doctag">@link</span> #array backing array&#125;,</span></span><br><span class="line"><span class="comment">  * and its &#123;<span class="doctag">@link</span> #arrayOffset array offset&#125; will be zero.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment">  *         The new buffer's capacity, in bytes</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">  *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HeapByteBuffer(int cap, int lim) &#123;           </span><br><span class="line"></span><br><span class="line">    super(-1, 0, lim, cap, new byte[cap], 0);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapByteBuffer(byte[] buf, int off, int len) &#123;</span><br><span class="line"></span><br><span class="line">    super(-1, off, off + len, buf.length, buf, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected HeapByteBuffer(byte[] buf,</span><br><span class="line">                               int mark, int pos, int lim, int cap,</span><br><span class="line">                               int off) &#123;</span><br><span class="line">    super(mark, pos, lim, cap, buf, off);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>        We can see it invoke superclass's constructor, so its data will store in the Heap.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;java-nio-buffer&quot;&gt;java NIO buffer&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;   A buffer Object is a container of a fixed amount of data, it acts as a bloc
      
    
    </summary>
    
      <category term="NIO" scheme="http://www.cfad.tech/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://www.cfad.tech/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>The introduce of NIO</title>
    <link href="http://www.cfad.tech/2017/12/09/NIO/nio1/"/>
    <id>http://www.cfad.tech/2017/12/09/NIO/nio1/</id>
    <published>2017-12-09T01:34:14.000Z</published>
    <updated>2017-12-11T15:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="the-introduce-of-nio">The introduce of NIO</span></h1><h2><span id="what-is-nio">What is NIO？</span></h2><p>          java.nio (non-blocking I/O) is a collection of Java programming language APIs that offer features for intensive I/O operations. It was introduced with the J2SE 1.4 release of Java by Sun Microsystems to complement an existing standard I/O<br>&lt;p style=&quot;text-align: right;&quot;&gt;---reference wiki&lt;/p&gt;</p><h2><span id="the-compare-between-nio-and-io">The compare between NIO and IO</span></h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>Stream Oriented</td><td>Buffer Oriented</td></tr><tr><td>Blocking IO</td><td>Non Blocking IO</td></tr><tr><td></td><td>Selectors</td></tr></tbody></table><h2><span id="the-function-of-nio">The function of NIO</span></h2><p>   When it comes to NIO, we should what is IO. In the traditional IO, we read or store data in the form of stream, so it is easy to cause obstruction that we difficult calls in multiple threads.But in NIO,The problem has a good way to solve it, the way is that we convey information by channel. in the channel, we can construct the corresponding buffer to transfer data. so we can say it is base on <strong>Buffer Oriented</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;the-introduce-of-nio&quot;&gt;The introduce of NIO&lt;/span&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;span id=&quot;what-is-nio&quot;&gt;What is NIO？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;          java.n
      
    
    </summary>
    
      <category term="NIO" scheme="http://www.cfad.tech/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://www.cfad.tech/tags/NIO/"/>
    
  </entry>
  
</feed>
